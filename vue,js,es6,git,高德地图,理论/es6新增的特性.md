# 								es6新增的特性

### 1.es6新增了的些属性？

```
新增了let  const  class promise, Map,Set,proxy,async和await,以及一些对象和数组的方法,扩展运算符常用的就这些,不常用的有类似于Generator函数,遍历器,生成函数,这些大概了解过
```



### 2.let,const和var

```es6
**（1）块级作用域： 块作用域由 `{ }`包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：

- 内层变量可能覆盖外层变量
- 用来计数的循环变量泄露为全局变量

**（2）变量提升：var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。

**（3）重复声明：var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。

**（4）暂时性死区：在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为**暂时性死区**。使用var声明的变量不存在暂时性死区。

**（5）初始值设置：在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。

**（6）指针指向：let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。

**（7）在es6之前只有全局作用域和函数作用域,在es6以后才有了块级作用域
```

### 3.箭头函数

```es6
1. this是动态的, `this`的值取决于函数本身被谁调用
2. 没有arguments伪数组,如果有绝对是来自于父组件
3. 不能作为构造实例化对象
```



### 4.什木是Promise？

```
1.Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。

2.promise本身只是一个容器,真正异步的是它的两个回调resolve()和reject()
```

### 5.promise实例有哪些状态，怎么改变状态?

```
（1）Promise的实例有**三个状态**:
- Pending（进行中）- Resolved（已完成）- Rejected（已拒绝）

当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成	了Rejected。

**如何改变 promise 的状态**
- resolve(value): 如果当前是 pending 就会变为 resolved
- reject(error): 如果当前是 pending 就会变为 rejected
- 抛出异常: 如果当前是 pending 就会变为 rejected

```

### 6.Promise有哪些实例方法

```
**then**

`then`方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为`resolved`时调用，第二个回调函数是Promise对象的状态变为`rejected`时调用。其中第二个参数可以省略。 `then`方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即`then`方法后面再调用另一个then方法。

**catch**

该方法相当于`then`方法的第二个参数，指向`reject`的回调函数。不过`catch`方法还有一个作用，就是在执行`resolve`回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入`catch`方法中。

**finally**

`finally`方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的
```

### 7.默认参数

```
在ES5之前是没有函数默认值的。函数的默认值是ES6的新语法

函数的默认值是给函数的形参设置一个默认值, 当你没有传递实参的时候来使用
```

### 8.扩展运算符

```
【...】扩展运算符【数组】转换为逗号分隔的【参数序列】
```

### 9.模板字符串

```
模板字符串就是模板字符串
```

10.迭代器和生成器

```
生成器函数,根据遍历器进行封装
* 都有next函数,每次调用都会重新生成一个生成器函数

```

### 10.Map对象

```
（1）概念和出现的原因:JavaScript 的对象(Object) ，本质上是键值对的集合Hash 结构)，但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值(包括对象)都可以当作键。也就是说，Object 结构提供了“字符串一值”的对应，Map 结构提供了“值值”的对应，是一种更完善的 Hash 结构实现。如果你需要“键值对”的数据结构，Map 比 Object 更合适。

	（2） map的方法使用
		1.使用new Map()
		2.判断长度: map.size
		3.添加元素: map.setl
		4.获取键值: map.get
		5，判断当前对象存不存在该属性: map.has
		6.删除当前对象中的属性: map.delete
		7.清空该方法的所有成员: map.clear
```

### 10.set数组

```
(1) 概念: ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值.
   (2) 本质: 是一个构造函数，
   (3) set的实例遍历操作
   	· Set.prototype.keys() : 返回键名的遍历器
   	· Set.prototype.valuesO) : 返回键值的遍历器
   	· Set.prototype.entries(): 返回键值对的遍历器
   	· Set.prototype.forEach() :使用回调函数遍历每个成员
   (4) 方法总结
   	1.获取元素的个数: array.size()
   	2.添加元素: array.add()
   	3.删除元素: array.delete()
   	4.检测是否存在这个值: array.has()
   	5.清空: array.clear()
```

### 11.class类

```
(1) ES6 提供了更接近传统语言的写法，引入了 Class(类)这个概念，作为对象的模板。通过 cLass 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 lass 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的 cLass 改写，就是下面这样。

1.概念:类(class)通过 static 关键字定义静态方法。不能在类的实例上调用静态方法，而应该通过类本身调用。这些通常是实用程序方法，例如创建或克隆对象的功能。
```

### 12.解构赋值

```
变量的结构赋值
     * 1. 数组的结构赋值
     *      1). 数组结构赋值的时候,不能使用字符串
     *      2). 数组结构通过下标形式结构
     * 2. 对象的结构赋值
     *       1). 通过属性名进行结构,
     *       2). 属性重命名	
```

### 13.对象的方法 Object.assgin

```
该方法用于将一个或多个源对象的所有可枚举属性复制到目标对象中，并返回目标对象
Object.assign(target, ...sources)
其中，target 是目标对象，sources 是一个或多个源对象，通过逗号分隔。
```

### 14.Array.isarray

```
Array.isarray是es6新增的检测数据类型
```

### 15.Symbol,bigint是新曾的基本数据类型